[{"id":0,"href":"/docs/posts/","title":"Atualizações","section":"Docs","content":"Anúncios gerais.\n"},{"id":1,"href":"/docs/disciplinas/poo-info/revisao-javascript/1-fundamentos/","title":"1. Fundamentos essenciais da linguagem","section":"JavaScript - uma breve introdução à linguagem","content":"1. Fundamentos essenciais da linguagem# JavaScript é uma linguagem de programação interpretada, dinâmica e multiparadigma, criada originalmente para rodar nos navegadores. Hoje, com ambientes como o Node.js, ela também está presente no servidor, em ferramentas de linha de comando e em aplicações desktop.\nPor ter sido projetada para ser acessível e flexível, JavaScript carrega algumas decisões de design que podem surpreender programadores vindos de outras linguagens: tipos que se convertem automaticamente, valores que se comportam diferente dependendo do contexto, e operadores que produzem resultados inesperados se não forem bem compreendidos.\nEste capítulo cobre os fundamentos da linguagem que qualquer desenvolvedor JavaScript precisa dominar; não apenas para escrever código que funciona, mas para entender por que ele funciona.\nExecução no navegador (console do DevTools)# Nem sempre é necessário criar arquivos ou abrir uma IDE para testar código JavaScript. Uma das grandes vantagens da linguagem é poder executá-la diretamente no navegador, por meio do console do DevTools.\nPara abrir o console:\nChrome / Edge: F12 ou Ctrl + Shift + J Firefox: F12 ou Ctrl + Shift + K O console permite:\nExecutar código JavaScript de forma imediata Testar expressões isoladas Experimentar funções e estruturas da linguagem Inspecionar valores, variáveis e objetos Observar erros e comportamentos inesperados Ao longo desta revisão, o console será nossa principal ferramenta de experimentação.\nExemplo prático:\nconsole.log(\u0026#34;Olá, mundo!\u0026#34;); let soma = 10 + 5; console.log(\u0026#34;A soma é:\u0026#34;, soma);Observe que:\nconsole.log exibe informações no console; o JavaScript executa cada linha imediatamente após você pressionar Enter. let, const e escopo de bloco# JavaScript possui três formas de declarar variáveis: var, let e const.\nNesta disciplina, não utilizaremos var, pois ela ignora escopo de bloco e pode gerar comportamentos confusos.\nEscopo de bloco# Variáveis declaradas com let e const só existem dentro do bloco {} onde foram declaradas.\nfor (let i = 0; i \u0026lt; 3; i++) { console.log(i); // 0, 1, 2 } // console.log(i); // Erro! \u0026#39;i\u0026#39; não existe fora do for Isso evita conflitos e efeitos colaterais, algo essencial quando trabalhamos com sistemas maiores\nlet# Usado quando o valor da variável pode mudar Possui escopo de bloco let idade = 25; idade = 26; // OK - pode reatribuir if (true) { let nome = \u0026#34;Maria\u0026#34;; console.log(nome); // \u0026#34;Maria\u0026#34; } // console.log(nome); // Erro! \u0026#39;nome\u0026#39; só existe dentro do bloco if const# Usado quando a variável não deve ser reatribuída Também possui escopo de bloco const PI = 3.14159; // PI = 3.14; // Erro! Não pode reatribuir uma constante const numeros = [1, 2, 3]; numeros[0] = 4; // OK - pode modificar os valores // numeros = [5, 6]; // Erro! Não pode reatribuir a constante Regra prática: Use const sempre que possível. Use let apenas quando precisar reatribuir.\nTipos primitivos: number, string, boolean, undefined, null# JavaScript possui tipos primitivos, que representam valores simples e imutáveis. Use typeof para inspecionar o tipo de um valor; por exemplo, para descobrir qual o tipo do resultado de uma expressão.\nAntes de avançar, vale entender como o JavaScript funciona. Diferente de linguagens mais rígidas, o JavaScript tenta ser flexível, convertendo tipos automaticamente.\nIsso gera consequências importantes, como código mais rápido de escrever e menos verboso (menos comandos para executar uma ação). Entretanto, com essas vantagens vêm algumas desvantagens. Um programador iniciante pode criar código repleto de conversões invisíveis, resultados inesperados e bugs difíceis de perceber.\nnumber# Representa todos os números, inteiros ou decimais.\nlet inteiro = 42; let decimal = 3.14; let negativo = -10; let infinito = Infinity; let naoNumero = NaN; // Not a Number console.log(typeof inteiro); // \u0026#34;number\u0026#34; Em JavaScript, não existe int ou float. Todo tipo numérico é number.\nstring# Representa texto. Pode ser declarada com aspas simples, duplas ou acento grave (crase).\nlet nome = \u0026#34;João\u0026#34;; let sobrenome = \u0026#34;Silva\u0026#34;; let frase = `Olá, ${nome} ${sobrenome}!`; // Template literal console.log(typeof nome); // \u0026#34;string\u0026#34; O uso de template literals (crase) facilita a composição de strings dinâmicas.\nboolean# Representa valores lógicos.\nlet ativo = true; let bloqueado = false; console.log(typeof ativo); // \u0026#34;boolean\u0026#34; undefined# Variável declarada mas não inicializada (ou seja, não recebeu valor).\nlet x; console.log(x); // undefined console.log(typeof x); // \u0026#34;undefined\u0026#34; null# Representa ausência intencional de valor.\nlet usuario = null; // Nenhum usuário selecionado console.log(typeof null); // \u0026#34;object\u0026#34; (comportamento histórico do JS) Apesar do typeof, null não é um objeto.\nO NaN - Not a Number# NaN significa Not a Number, um valor especial em JavaScript que tem comportamentos únicos.\n1. NaN é do tipo number\ntypeof NaN; // \u0026quot;number\u0026quot;\nIsso acontece porque NaN representa um erro dentro do sistema numérico do JavaScript.\n2. NaN não é igual a ele mesmo\nEste é um dos comportamentos mais estranhos da linguagem:\nNaN === NaN; // false NaN == NaN; // false Em JavaScript, NaN representa um valor inválido e dois valores inválidos não são considerados iguais.\n3. Como detectar corretamente\nNunca compare com NaN diretamente.\nErrado: valor === NaN;\nCorreto: Number.isNaN(valor);\nExemplo:\nlet x = Number(\u0026#34;abc\u0026#34;); Number.isNaN(x); // true As situações comuns que resultam em NaN são:\nNumber(\u0026#34;abc\u0026#34;); // NaN 0 / 0; // NaN \u0026#34;texto\u0026#34; - 1; // NaN Math.sqrt(-1); // NaN Operadores aritméticos, relacionais e lógicos# Operadores são os símbolos que dizem ao JavaScript o que fazer com os valores. Toda expressão na linguagem — de um simples cálculo a uma condição complexa — é construída com eles. Nesta seção, você vai conhecer os três grupos principais: os que realizam cálculos, os que comparam valores e os que combinam condições lógicas.\nOperadores aritméticos# Realizam operações matemáticas.\nlet a = 10, b = 3; console.log(a + b); // 13 - Adição console.log(a - b); // 7 - Subtração console.log(a * b); // 30 - Multiplicação console.log(a / b); // 3.333... - Divisão console.log(a % b); // 1 - Resto da divisão (módulo) console.log(a ** b); // 1000 - Exponenciação // Operadores de incremento/decremento let contador = 5; contador++; // contador = 6 contador--; // contador = 5 Operadores relacionais# Comparam valores e retornam boolean.\nlet x = 10, y = 5; console.log(x \u0026gt; y); // true - Maior que console.log(x \u0026lt; y); // false - Menor que console.log(x \u0026gt;= 10); // true - Maior ou igual console.log(x \u0026lt;= 5); // false - Menor ou igual console.log(x == y); // false - Igual (com conversão de tipo) console.log(x === y); // false - Estritamente igual console.log(x != y); // true - Diferente (com conversão) console.log(x !== y); // true - Estritamente diferente Operadores lógicos# Combinam expressões booleanas.\nlet temCNH = true; let maiorDeIdade = true; let estaCansado = false; // AND (\u0026amp;\u0026amp;) - Retorna true se AMBOS forem true console.log(temCNH \u0026amp;\u0026amp; maiorDeIdade); // true console.log(temCNH \u0026amp;\u0026amp; estaCansado); // false // OR (||) - Retorna true se PELO MENOS UM for true console.log(temCNH || estaCansado); // true console.log(false || false); // false // NOT (!) - Inverte o valor booleano console.log(!estaCansado); // true console.log(!temCNH); // false Conversão implícita vs explícita# Uma das características mais marcantes do JavaScript é a sua flexibilidade com tipos. Ao contrário de linguagens mais rígidas, onde misturar um número com uma string gera um erro, o JavaScript tenta tratar a situação por conta própria, convertendo valores automaticamente para que a operação faça sentido. Esse comportamento se chama coerção, e embora pareça conveniente, é uma das principais fontes de bugs em código JavaScript.\nEntender quando o JavaScript converte tipos sozinho, e quando você deve fazer isso explicitamente, é essencial para escrever código previsível.\nConversão implícita (coerção)# JavaScript converte automaticamente tipos em certas operações.\n// String + Number = String (concatenação) console.log(\u0026#34;10\u0026#34; + 5); // \u0026#34;105\u0026#34; console.log(\u0026#34;Idade: \u0026#34; + 25); // \u0026#34;Idade: 25\u0026#34; // Operações matemáticas convertem para number console.log(\u0026#34;10\u0026#34; - 5); // 5 console.log(\u0026#34;10\u0026#34; * \u0026#34;2\u0026#34;); // 20 console.log(\u0026#34;10\u0026#34; / \u0026#34;2\u0026#34;); // 5 // Boolean em contexto numérico console.log(true + 1); // 2 console.log(false + 1); // 1 Essas conversões automáticas são uma fonte comum de bugs.\nConversão explícita# Você força a conversão usando funções.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Converter para Number console.log(Number(\u0026#34;42\u0026#34;)); // 42 console.log(Number(\u0026#34;3.14\u0026#34;)); // 3.14 console.log(Number(\u0026#34;abc\u0026#34;)); // NaN console.log(Number(true)); // 1 console.log(Number(false)); // 0 // Alternativas para converter para número console.log(parseInt(\u0026#34;42\u0026#34;)); // 42 (inteiro) console.log(parseFloat(\u0026#34;3.14\u0026#34;)); // 3.14 (decimal) console.log(+\u0026#34;42\u0026#34;); // 42 (operador unário +) // Converter para String console.log(String(42)); // \u0026#34;42\u0026#34; console.log(String(true)); // \u0026#34;true\u0026#34; console.log(String(null)); // \u0026#34;null\u0026#34; // Alternativas para converter para string console.log((42).toString()); // \u0026#34;42\u0026#34; console.log(42 + \u0026#34;\u0026#34;); // \u0026#34;42\u0026#34; // Converter para Boolean console.log(Boolean(1)); // true console.log(Boolean(0)); // false console.log(Boolean(\u0026#34;texto\u0026#34;)); // true console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(!!42); // true (dupla negação) Na linha 11, você vê uma menção a um operador unário. Este é um operador que atua sobre um único operando (um único valor).\nEm JavaScript, alguns operadores unários são usados com frequência para conversão de tipos.\nOperador unário + (conversão para número)# O operador +, quando usado antes de um valor, tenta converter esse valor para o tipo number.\n+\u0026#34;42\u0026#34;; // 42 +\u0026#34;3.14\u0026#34;; // 3.14 +\u0026#34;abc\u0026#34;; // NaN +true; // 1 +false; // 0 Esse operador funciona de forma semelhante a Number():\nNumber(\u0026#34;42\u0026#34;); // 42 Operador unário !! (conversão explícita para boolean)# O !! não é um operador próprio da linguagem. Ele é o resultado da aplicação do operador unário de negação (!) duas vezes seguidas.\n!valor; // nega o valor lógico !!valor; // nega a negação, forçando um boolean Passo a passo do que acontece\nConsidere o valor# let x = \u0026#34;texto\u0026#34;; Primeira negação (!x)# \u0026ldquo;texto\u0026rdquo; é um valor truthy (interpretado como true) !x resulta em false !x; // false Segunda negação (!!x)# false é negado novamente o resultado final é true !!x; // true Ou seja, o JavaScript converte o valor para boolean e retorna esse boolean explícito.\nExemplos comuns\n!!42; // true !!0; // false !!\u0026#34;texto\u0026#34;; // true !!\u0026#34;\u0026#34;; // false !!null; // false !!undefined; // false Esses resultados seguem as regras de valores truthy e falsy do JavaScript.\nO que é truthy e falsy?# Em JavaScript, nem todo valor booleano vem de true ou false. Em muitos contextos, a linguagem converte valores automaticamente para booleano. Isso significa que, onde quer que esses valores sejam usados, eles serão interpretados como boolean. Por exemplo, na condição de um if.\nValores falsy\nEstes sempre viram false:\nfalse 0 \u0026quot;\u0026quot; (string vazia) null undefined NaN Valores truthy\nTodo valor que não está na lista acima é truthy.\nExemplos:\nBoolean(\u0026quot;0\u0026quot;); // true Boolean(\u0026quot;false\u0026quot;); // true Boolean([]); // true Boolean({}); // true Boolean(42); // true Comparação com Boolean()\nO efeito de !!valor é o mesmo que Boolean(valor)\nExemplo:\nBoolean(10); // true !!10; // true A diferença está apenas na forma, não no resultado. Quando o !! aparece em código real, é frequentemente usado:\npara garantir que uma expressão resulte em true ou false em validações rápidas em condições complexas Exemplo:\nif (!!usuario) { console.log(\u0026#34;Usuário existe\u0026#34;); }Esse código poderia ser escrito de forma mais legível como:\nif (usuario !== null) { console.log(\u0026#34;Usuário existe\u0026#34;); }Apesar de comum em código JavaScript real, o uso de !! não é obrigatório, pode reduzir a legibilidade para iniciantes e não deve ser usado como \u0026ldquo;atalho\u0026rdquo; sem entendimento.\nO !! foi apresentado aqui apenas como algo que o estudante precisa reconhecer e compreender, não necessariamente usar. Por simplicidade e clareza, prefira Boolean(valor).\nOperadores ==, ===, != e !==# O operador == faz conversão de tipos antes de comparar (coerção), enquanto === compara valor E tipo.\nExemplos comparativos:\n// Igualdade com conversão (==) console.log(5 == \u0026#34;5\u0026#34;); // true - converte \u0026#34;5\u0026#34; para número console.log(true == 1); // true - converte true para 1 console.log(false == 0); // true - converte false para 0 console.log(null == undefined); // true - caso especial console.log(\u0026#34;\u0026#34; == 0); // true - string vazia vira 0 // Igualdade estrita (===) console.log(5 === \u0026#34;5\u0026#34;); // false - tipos diferentes console.log(true === 1); // false - tipos diferentes console.log(false === 0); // false - tipos diferentes console.log(null === undefined); // false - tipos diferentes console.log(\u0026#34;\u0026#34; === 0); // false - tipos diferentes // Casos curiosos console.log([1] == 1); // true - array é convertido console.log([1] === 1); // false - tipos diferentes Recomendação: Use sempre === e !== em vez de == e != para evitar bugs causados por conversões inesperadas.\nAtividades sugeridas# As atividades a seguir devem ser feitas primeiro no papel ou mentalmente, e só depois testadas no console.\nAnalise as expressões abaixo e preveja o resultado antes de executar no console: // Exercício 1 let resultado1 = \u0026#34;5\u0026#34; + 3; // Exercício 2 let resultado2 = \u0026#34;5\u0026#34; - 3; // Exercício 3 let resultado3 = \u0026#34;10\u0026#34; * \u0026#34;2\u0026#34;; // Exercício 4 let resultado4 = true + true + false; // Exercício 5 let resultado5 = \u0026#34;20\u0026#34; / \u0026#34;4\u0026#34; + 5; // Exercício 6 let resultado6 = 10 \u0026gt; 5 \u0026amp;\u0026amp; 3 \u0026lt; 2; // Exercício 7 let resultado7 = \u0026#34;abc\u0026#34; - 1; // Exercício 8 let resultado8 = null + 10; // Exercício 9 let resultado9 = undefined + 5; // Exercício 10 let resultado10 = \u0026#34;5\u0026#34; === 5; Ver respostas do Exercício 1 \u0026quot;53\u0026quot; (concatenação) 2 (subtração numérica) 20 (multiplicação numérica) 2 (true=1, false=0) 10 (5 + 5) false (10\u0026gt;5 é true, mas 3\u0026lt;2 é false) NaN (não é possível subtrair de string) 10 (null vira 0) NaN (undefined não converte bem) false (tipos diferentes) Identifique e corrija os erros no código abaixo: // Código com erro if (true) { var mensagem = \u0026#34;Olá\u0026#34;; } console.log(mensagem); // Funciona com var, mas não é boa prática Ver correção do Exercício 2 // Código corrigido let mensagem; if (true) { mensagem = \u0026#34;Olá\u0026#34;; } console.log(mensagem); Identifique e corrija os erros no código abaixo: // Código com erro for (let i = 0; i \u0026lt; 3; i++) { // ... } console.log(i); // Erro! \u0026#39;i\u0026#39; não existe fora do for Ver correção do Exercício 3 // Código corrigido let i; for (i = 0; i \u0026lt; 3; i++) { // ... } console.log(i); // Agora funciona Identifique e corrija os erros no código abaixo: // Código com erro const nome = \u0026#34;João\u0026#34;; nome = \u0026#34;Maria\u0026#34;; // Erro! Não pode reatribuir const Ver correção do Exercício 4 // Código corrigido - use let se precisar reatribuir let nome = \u0026#34;João\u0026#34;; nome = \u0026#34;Maria\u0026#34;; // OK Preveja o resultado (true ou false): 1. \u0026#34;0\u0026#34; == 0 // ? 2. \u0026#34;0\u0026#34; === 0 // ? 3. 0 == false // ? 4. 0 === false // ? 5. null == 0 // ? 6. undefined == null // ? 7. [] == false // ? 8. [] === false // ? Ver respostas do Exercício 5 true (conversão) false (tipos diferentes) true (conversão) false (tipos diferentes) false (null não converte para número em ==) true (caso especial) true (conversão complexa) false (tipos diferentes) Preveja o resultado: let x = \u0026#34;5\u0026#34;; let y = x * 2; let z = y + \u0026#34;1\u0026#34;; console.log(z); Explique o passo a passo de como a expressão a seguir é avaliada: let resultado = \u0026#34;5\u0026#34; + 5 * 2; console.log(resultado); Considere o código a seguir. O que será exibido e por que a saída do código é essa? let a = Number(\u0026#34;abc\u0026#34;); console.log(a === NaN); console.log(Number.isNaN(a)); Preveja quais linhas imprimem algo: if (\u0026#34;\u0026#34;) console.log(\u0026#34;A\u0026#34;); if (\u0026#34;0\u0026#34;) console.log(\u0026#34;B\u0026#34;); if (0) console.log(\u0026#34;C\u0026#34;); if ([]) console.log(\u0026#34;D\u0026#34;); if (null) console.log(\u0026#34;E\u0026#34;); if (\u0026#34;false\u0026#34;) console.log(\u0026#34;F\u0026#34;); Explique com suas palavras por que \u0026quot;5\u0026quot; + 5 e \u0026quot;5\u0026quot; - 5 produzem resultados de tipos diferentes?\nO código abaixo pode ser interpretado de duas formas diferentes:\nlet total = \u0026#34;100\u0026#34; + 20;a) Qual é o resultado atual?\nb) Por que o JavaScript escolhe esse comportamento?\nc) Reescreva o código para forçar concatenação\nd) Reescreva o código para forçar soma numérica\nComplete o código: let valor = Number(\u0026#34;texto\u0026#34;); // Imprima \u0026#34;Número inválido\u0026#34; se for NaN "},{"id":2,"href":"/docs/disciplinas/poo-info/revisao-javascript/2-estruturas-controle/","title":"2. Estruturas de controle","section":"JavaScript - uma breve introdução à linguagem","content":"2. Estruturas de controle# As estruturas de controle determinam como e quando determinadas partes do código são executadas. Elas são fundamentais para expressar lógica, tomar decisões e repetir ações.\nO objetivo desta seção é reforçar o raciocínio lógico e a capacidade de acompanhar o fluxo de execução de um programa.\nEstruturas condicionais: if, else, else if# Estas estruturas determinam a execução condicional de um bloco, ou seja, se os comandos dentro de chaves ({}) vão executar ou não, com base no valor booleano de uma expressão, chamada de condição.\nAs condições utilizam operadores de comparação como \u0026gt;=, \u0026lt;=, ===, !==, \u0026gt;, \u0026lt; para definir quando um bloco de código será executado. O resultado da condição é sempre booleano: true ou false.\nif# A estrutura if permite executar um bloco de código apenas se uma condição for verdadeira.\nlet idade = 18; if (idade \u0026gt;= 18) { console.log(\u0026#34;Maior de idade\u0026#34;); }Se a condição for falsa, o bloco não é executado. O fluxo de execução continua com o código após o if.\nExemplo prático: Validar se um usuário pode acessar um recurso\nlet usuario = { nome: \u0026#34;Ana\u0026#34;, premium: true, }; if (usuario.premium) { console.log( `Bem-vinda, ${usuario.nome}! Você tem acesso a todos os recursos.`, ); }if + else# Quando precisamos executar uma de duas ações possíveis, usamos else. Exatamente um dos dois blocos será executado.\nlet nota = 6; if (nota \u0026gt;= 7) { console.log(\u0026#34;Aprovado\u0026#34;); } else { console.log(\u0026#34;Reprovado\u0026#34;); }O else é executado quando a condição do if é falsa.\nExemplo prático: Aplicar desconto ou preço cheio\nlet valor = 150; let temDesconto = true; let precoFinal; if (temDesconto) { precoFinal = valor * 0.9; // 10% de desconto console.log(`Preço com desconto: R$ ${precoFinal.toFixed(2)}`); } else { precoFinal = valor; console.log(`Preço: R$ ${precoFinal.toFixed(2)}`); }else if# Usado quando existem várias condições possíveis, mas apenas uma deve ser executada. Permite criar uma cadeia de decisões.\nlet nota = 8; if (nota \u0026gt;= 9) { console.log(\u0026#34;Excelente\u0026#34;); } else if (nota \u0026gt;= 7) { console.log(\u0026#34;Aprovado\u0026#34;); } else if (nota \u0026gt;= 5) { console.log(\u0026#34;Recuperação\u0026#34;); } else { console.log(\u0026#34;Reprovado\u0026#34;); } A avaliação ocorre de cima para baixo. Assim que uma condição é verdadeira, as demais são ignoradas. Por isso, a ordem das condições é importante!\nExemplo prático: Classificar temperatura\nlet temperatura = 22; if (temperatura \u0026gt; 30) { console.log(\u0026#34;Quente! Use roupas leves.\u0026#34;); } else if (temperatura \u0026gt; 20) { console.log(\u0026#34;Agradável! Ótimo tempo.\u0026#34;); } else if (temperatura \u0026gt; 10) { console.log(\u0026#34;Fresco! Leve um casaco.\u0026#34;); } else { console.log(\u0026#34;Muito frio! Use casaco pesado.\u0026#34;); }Fluxo de execução com if/else if/else:\nflowchart TD A[Christmas] --\u0026gt;|Get money| B(Go shopping) B --\u0026gt; C{Let me think} C --\u0026gt;|One| D[Laptop] C --\u0026gt;|Two| E[iPhone] C --\u0026gt;|Three| F[fa:fa-car Car]┌─────────────────┐ │ Verificar T │ └────────┬────────┘ │ ┌────▼─────┐ │ T \u0026gt; 30? │─── Sim ──► \u0026#34;Quente\u0026#34; └────┬─────┘ │ Não ┌────▼─────┐ │ T \u0026gt; 20? │─── Sim ──► \u0026#34;Agradável\u0026#34; └────┬─────┘ │ Não ┌────▼─────┐ │ T \u0026gt; 10? │─── Sim ──► \u0026#34;Fresco\u0026#34; └────┬─────┘ │ Não └──────► \u0026#34;Muito frio\u0026#34;Estrutura switch# O switch é uma alternativa ao uso de vários else if quando se deseja comparar um mesmo valor contra diferentes opções. É particularmente útil quando há muitas opções e o código fica mais legível.\nSintaxe e funcionamento# let dia = 3; switch (dia) { case 1: console.log(\u0026#34;Segunda-feira\u0026#34;); break; case 2: console.log(\u0026#34;Terça-feira\u0026#34;); break; case 3: console.log(\u0026#34;Quarta-feira\u0026#34;); break; default: console.log(\u0026#34;Dia inválido\u0026#34;); }A estrutura funciona assim:\nO valor de dia é avaliado uma única vez O JavaScript procura um case que correspondaexatamente ao valor (usando ===) Se encontrar, começa a executar a partir desse ponto O break interrompe a execução do switch Se nenhum case corresponder, o bloco default é executado Comparação: if/else if vs switch\nAmbos resolvem o mesmo problema, mas em contextos diferentes:\nAspecto if/else if switch Bom para Condições complexas Comparações contra múltiplos valores Legibilidade Melhor para poucas opções Melhor com muitas opções Comparação Qualquer operador (\u0026gt;, \u0026lt;, ===, etc) Apenas === (igualdade exata) Exemplo if (x \u0026gt; 5 \u0026amp;\u0026amp; y \u0026lt; 10) switch (tipoUsuario) Papel do break# O break interrompe a execução do switch, impedindo que o fluxo continue para o próximo case. Sem ele, ocorre o chamado fall-through (queda em cascata).\nlet valor = 1; switch (valor) { case 1: console.log(\u0026#34;Um\u0026#34;); case 2: console.log(\u0026#34;Dois\u0026#34;); } // Resultado SEM break: // Um // Dois // Resultado COM break: // Um Observe: o segundo case é executado mesmo sem corresponder ao valor, porque não há break após o primeiro.\nEsquecer o break é um erro comum e difícil de detectar. Use-o em cada case, a menos que o comportamento de queda seja intencional.\nFall-through intencional no switch# Apesar de frequentemente causar erros, o fall-through pode ser usado de forma intencional e controlada, quando vários cases devem executar o mesmo código.\nlet dia = 6; switch (dia) { case 1: case 2: case 3: case 4: case 5: console.log(\u0026#34;Dia útil\u0026#34;); break; case 6: case 7: console.log(\u0026#34;Fim de semana\u0026#34;); break; default: console.log(\u0026#34;Dia inválido\u0026#34;); }Nesse exemplo:\nSe dia for 1, 2, 3, 4 ou 5, imprime \u0026ldquo;Dia útil\u0026rdquo; Se dia for 6 ou 7, imprime \u0026ldquo;Fim de semana\u0026rdquo; Os cases \u0026ldquo;caem\u0026rdquo; no mesmo bloco de forma controlada O break evita que o código \u0026ldquo;caia\u0026rdquo; para o próximo grupo de cases.\nExemplo prático: Validar permissões de acesso\nlet papel = \u0026#34;admin\u0026#34;; switch (papel) { case \u0026#34;admin\u0026#34;: case \u0026#34;moderador\u0026#34;: console.log(\u0026#34;Pode deletar usuários\u0026#34;); break; case \u0026#34;editor\u0026#34;: case \u0026#34;autor\u0026#34;: console.log(\u0026#34;Pode criar conteúdo\u0026#34;); break; case \u0026#34;visitante\u0026#34;: console.log(\u0026#34;Acesso somente leitura\u0026#34;); break; default: console.log(\u0026#34;Papel desconhecido\u0026#34;); }Laços de repetição# Laços permitem repetir um bloco de código diversas vezes enquanto uma condição for satisfeita. Eles são essenciais para processar coleções de dados, validações ou criar padrões.\nQuando usar cada laço?# Laço Melhor para Conhecemos o fim? for Conhecer o número de repetições Sim - geralmente while Condição complexa Não - depende de uma condição do...while Garantir execução mínima Não - mas pelo menos uma vez for# Usado quando o número de repetições é conhecido ou controlado por um contador. É o laço mais versátil.\nfor (let i = 0; i \u0026lt; 5; i++) { console.log(i); } // Resultado: // 0 // 1 // 2 // 3 // 4 Estrutura do for:\nfor (inicialização; condição; atualização) { // bloco de código } inicialização: executada uma única vez, antes do laço começar condição: verificada antes de cada iteração atualização: executada após cada iteração Exemplo prático: Tabuada\nlet numero = 7; for (let i = 1; i \u0026lt;= 10; i++) { let resultado = numero * i; console.log(`${numero} × ${i} = ${resultado}`); } // Resultado: // 7 × 1 = 7 // 7 × 2 = 14 // 7 × 3 = 21 // ... A variável i é criada com let, então existe apenas dentro do laço.\nVariações do for:\n// Regressivo (contador decrescente) for (let i = 5; i \u0026gt; 0; i--) { console.log(i); } // Pulando valores for (let i = 0; i \u0026lt; 20; i += 5) { console.log(i); // 0, 5, 10, 15 } // Múltiplas variáveis for (let i = 0, j = 10; i \u0026lt; j; i++, j--) { console.log(`i=${i}, j=${j}`); }while# Executa um bloco enquanto uma condição for verdadeira. A condição é verificada antes de cada execução.\nlet contador = 0; while (contador \u0026lt; 3) { console.log(contador); contador++; } // Resultado: // 0 // 1 // 2 Use while quando a condição é complexa ou quando você não sabe quantas vezes o laço deve rodar.\nExemplo prático: Ler dados até uma entrada específica\nlet senha = \u0026#34;\u0026#34;; let tentativas = 0; let maxTentativas = 3; while (tentativas \u0026lt; maxTentativas \u0026amp;\u0026amp; senha !== \u0026#34;1234\u0026#34;) { // Em um programa real, isso viria de uma entrada do usuário senha = prompt(`Senha (tentativa ${tentativas + 1}/${maxTentativas}):`); tentativas++; } if (senha === \u0026#34;1234\u0026#34;) { console.log(\u0026#34;Acesso permitido!\u0026#34;); } else { console.log(\u0026#34;Acesso negado! Máximo de tentativas excedido.\u0026#34;); } Se a condição nunca se tornar falsa, o laço será infinito e o programa travará!\n// CUIDADO: Laço infinito! let i = 0; while (i \u0026lt; 10) { console.log(i); // Falta i++ - a condição nunca fica falsa }do...while# Semelhante ao while, mas a condição é verificada após a execução. Isso garante que o bloco seja executado pelo menos uma vez.\nlet numero = 5; do { console.log(numero); numero++; } while (numero \u0026lt; 3); // Resultado: // 5 // (mesmo com condição falsa, executa uma vez) Compare com while:\nlet numero = 5; while (numero \u0026lt; 3) { console.log(numero); // Nunca é executado! numero++; }Exemplo prático: Menu que exige pelo menos uma entrada\nlet opcao; do { opcao = prompt(\u0026#34;Escolha:\\n1 - Continuar\\n2 - Sair\u0026#34;); if (opcao === \u0026#34;1\u0026#34;) { console.log(\u0026#34;Continuando...\u0026#34;); } else if (opcao === \u0026#34;2\u0026#34;) { console.log(\u0026#34;Encerrando...\u0026#34;); } else { console.log(\u0026#34;Opção inválida! Tente novamente.\u0026#34;); } } while (opcao !== \u0026#34;2\u0026#34;);break e continue em laços# break# Interrompe completamente o laço, passando para o código após o laço.\nfor (let i = 0; i \u0026lt; 10; i++) { if (i === 5) { break; // Sai do laço } console.log(i); } // Resultado: // 0 1 2 3 4 Exemplo prático: Procurar um valor em uma lista\nlet numeros = [3, 7, 2, 8, 15, 4]; let procurando = 8; let encontrado = false; for (let i = 0; i \u0026lt; numeros.length; i++) { if (numeros[i] === procurando) { console.log(`Encontrado na posição ${i}`); encontrado = true; break; // Não precisa continuar procurando } } if (!encontrado) { console.log(\u0026#34;Não encontrado\u0026#34;); }continue# Interrompe apenas a iteração atual, pulando para a próxima iteração.\nfor (let i = 0; i \u0026lt; 5; i++) { if (i === 2) { continue; // Pula esta iteração } console.log(i); } // Resultado: // 0 1 3 4 Exemplo prático: Processando apenas números válidos\nlet dados = [2, \u0026#34;texto\u0026#34;, 5, null, 8, undefined, 1]; for (let i = 0; i \u0026lt; dados.length; i++) { if (typeof dados[i] !== \u0026#34;number\u0026#34;) { continue; // Pula valores não numéricos } console.log(`Quadrado de ${dados[i]} é ${dados[i] ** 2}`); } // Resultado: // Quadrado de 2 é 4 // Quadrado de 5 é 25 // Quadrado de 8 é 64 // Quadrado de 1 é 1 Atividades sugeridas# 1. Exercícios de rastreamento (Trace)# Objetivo: Entender e prever o fluxo de execução sem rodar o código.\nNível 1: Básico# Antes de executar, escreva o que será impresso no console.\nlet x = 0; for (let i = 1; i \u0026lt;= 3; i++) { x += i; } console.log(x);Desafio: Qual é o valor de x ao final?\nlet i = 0; while (i \u0026lt; 5) { if (i === 3) { break; } console.log(i); i++; }Desafio: Qual é a saída?\nfor (let i = 0; i \u0026lt; 5; i++) { if (i === 2) { continue; } console.log(i); }Desafio: Qual é a saída?\nNível 2: Intermediário# let resultado = \u0026#34;\u0026#34;; for (let i = 1; i \u0026lt;= 3; i++) { for (let j = 1; j \u0026lt;= 2; j++) { resultado += `${i}${j},`; } } console.log(resultado);Desafio: Qual é o resultado final?\nlet x = 5; switch (x % 2) { case 0: console.log(\u0026#34;Par\u0026#34;); break; case 1: console.log(\u0026#34;Ímpar\u0026#34;); break; default: console.log(\u0026#34;Inválido\u0026#34;); }Desafio: O que será impresso?\nNível 3: Avançado# let nums = []; for (let i = 1; i \u0026lt;= 5; i++) { if (i % 2 === 0) { nums.push(i * 2); } else if (i \u0026gt; 3) { nums.push(i + 10); } else { nums.push(i); } } console.log(nums);Desafio: Qual é o array final?\nlet contador = 0; let i = 0; do { i++; if (i % 2 === 0) { continue; } contador++; } while (i \u0026lt; 6); console.log(contador);Desafio: Qual é o valor de contador?\n2. Exercícios práticos - Simuladores simples# 1.1 Contador com critério# Crie um programa que:\nComece em um número inicial Termine em um número final Mostre apenas os números pares let inicio = 1; let fim = 10; // complete o código // Saída esperada: 2 4 6 8 10 Dica: Use continue para pular números ímpares.\n1.2 Menu textual simples# Simule um menu usando switch. O programa deve:\nExibir as opções disponíveis Processar a escolha do usuário Executar a ação correspondente // Opções: // 1 - Cadastrar // 2 - Listar // 3 - Atualizar // 4 - Deletar // 5 - Sair let opcao = 2; // Simule uma entrada do usuário switch (opcao) { case 1: console.log(\u0026#34;Abrindo formulário de cadastro...\u0026#34;); // Código para cadastrar break; case 2: console.log(\u0026#34;Listando todos os registros...\u0026#34;); // Código para listar break; // Complete os demais cases default: console.log(\u0026#34;Opção inválida!\u0026#34;); }Desafio: Adicione validação para aceitar apenas números de 1 a 5.\n1.3 Validador de idade e acesso# Crie um programa que:\nValide se uma pessoa pode entrar em um estabelecimento Diferentes regras para diferentes idades Mostre mensagens apropriadas let idade = 25; let temIdentidade = true; if (idade \u0026lt; 18) { console.log(\u0026#34;Menores de 18 não são permitidos.\u0026#34;); } else if (idade \u0026gt;= 18 \u0026amp;\u0026amp; idade \u0026lt; 21) { if (temIdentidade) { console.log( \u0026#34;Pode entrar com restrições (não pode consumir bebida alcoólica).\u0026#34;, ); } else { console.log(\u0026#34;Necessário apresentar identidade.\u0026#34;); } } else { console.log(\u0026#34;Bem-vindo! Acesso total.\u0026#34;); }Desafio: Teste com diferentes valores de idade e temIdentidade.\n1.4 Calculadora de faixa de nota# Crie um programa que classifique notas:\nlet nota = 7.5; if (nota \u0026gt;= 9) { console.log(\u0026#34;A - Excelente\u0026#34;); } else if (nota \u0026gt;= 8) { console.log(\u0026#34;B - Muito bom\u0026#34;); } else if (nota \u0026gt;= 7) { console.log(\u0026#34;C - Bom\u0026#34;); } else if (nota \u0026gt;= 6) { console.log(\u0026#34;D - Satisfatório\u0026#34;); } else if (nota \u0026gt;= 5) { console.log(\u0026#34;E - Precisa melhorar\u0026#34;); } else { console.log(\u0026#34;F - Reprovado\u0026#34;); }Desafio: Refatore usando switch.\n3. Exercícios com laços - Padrões e cálculos# 3.1 Tabuada# Crie um programa que mostre a tabuada de um número:\nlet numero = 7; for (let i = 1; i \u0026lt;= 10; i++) { console.log(`${numero} × ${i} = ${numero * i}`); } // Saída esperada: // 7 × 1 = 7 // 7 × 2 = 14 // ... // 7 × 10 = 70 Desafio extras:\nDeixe o número como entrada Mostre apenas os resultados pares 3.2 Contagem com critério# Liste números de 1 a 20, mas:\nPor cada múltiplo de 3, escreva \u0026ldquo;Fizz\u0026rdquo; Por cada múltiplo de 5, escreva \u0026ldquo;Buzz\u0026rdquo; Por cada múltiplo de ambos, escreva \u0026ldquo;FizzBuzz\u0026rdquo; Pelos demais, escreva o número for (let i = 1; i \u0026lt;= 20; i++) { if (i % 15 === 0) { console.log(\u0026#34;FizzBuzz\u0026#34;); } else if (i % 3 === 0) { console.log(\u0026#34;Fizz\u0026#34;); } else if (i % 5 === 0) { console.log(\u0026#34;Buzz\u0026#34;); } else { console.log(i); } } 3.3 Verificar números primos# Determine se um número é primo:\nlet numero = 17; let ehPrimo = true; if (numero \u0026lt; 2) { ehPrimo = false; } else { for (let i = 2; i \u0026lt; numero; i++) { if (numero % i === 0) { ehPrimo = false; break; // Não precisa continuar } } } if (ehPrimo) { console.log(`${numero} é primo`); } else { console.log(`${numero} não é primo`); }Desafio: Optimizar para verificar apenas até Math.sqrt(numero).\n3.4 Soma e média# Calcule a soma e média de números:\nlet numeros = [15, 23, 8, 42, 16]; let soma = 0; for (let i = 0; i \u0026lt; numeros.length; i++) { soma += numeros[i]; } let media = soma / numeros.length; console.log(`Soma: ${soma}`); console.log(`Média: ${media.toFixed(2)}`);Desafio: Encontre também o maior e menor número no array.\n3.5 Padrão visual - Triângulo# Imprima um padrão:\n// Opção 1: Triângulo crescente for (let i = 1; i \u0026lt;= 5; i++) { let linha = \u0026#34;\u0026#34;; for (let j = 0; j \u0026lt; i; j++) { linha += \u0026#34;*\u0026#34;; } console.log(linha); } // Resultado: // * // ** // *** // **** // ***** Desafios:\nFaça um triângulo decrescente Faça um losango Aumente a dificuldade personalizando o símbolo 4. Exercícios de lógica complexa# 4.1 Validar entrada de senha# let senha = \u0026#34;Abc123!\u0026#34;; let valida = true; if (senha.length \u0026lt; 8) { console.log(\u0026#34;Senha muito curta\u0026#34;); valida = false; } else if (!/[A-Z]/.test(senha)) { console.log(\u0026#34;Falta letra maiúscula\u0026#34;); valida = false; } else if (!/[0-9]/.test(senha)) { console.log(\u0026#34;Falta número\u0026#34;); valida = false; } if (valida) { console.log(\u0026#34;Senha válida!\u0026#34;); } 4.2 Jogo: Adivinhação# let numeroSecreto = 42; let chute = 0; let tentativas = 0; let acertou = false; while (!acertou \u0026amp;\u0026amp; tentativas \u0026lt; 5) { // En um programa real, viria de entrada do usuário chute = Math.floor(Math.random() * 100); tentativas++; if (chute === numeroSecreto) { console.log(`Acertou em ${tentativas} tentativas!`); acertou = true; } else if (chute \u0026lt; numeroSecreto) { console.log(`${chute} é muito baixo`); } else { console.log(`${chute} é muito alto`); } } if (!acertou) { console.log(`Perdeu! O número era ${numeroSecreto}`); } 4.3 Filtrar e processar dados# let vendas = [ { produto: \u0026#34;Notebook\u0026#34;, valor: 3000 }, { produto: \u0026#34;Mouse\u0026#34;, valor: 50 }, { produto: \u0026#34;Teclado\u0026#34;, valor: 150 }, { produto: \u0026#34;Monitor\u0026#34;, valor: 800 }, ]; let totalVendas = 0; for (let i = 0; i \u0026lt; vendas.length; i++) { if (vendas[i].valor \u0026gt; 100) { console.log(`${vendas[i].produto}: R$ ${vendas[i].valor}`); totalVendas += vendas[i].valor; } } console.log(`Total (produtos \u0026gt; R$ 100): R$ ${totalVendas}`); 5. Desafios integrados# 5.1 Sistema de notas# Crie um programa que:\nReceba 3 notas de um aluno Calcule a média Mostre a classificação (A-F) Diga se passou ou reprovou 5.2 Conversor de categorias# Crie um programa que:\nReceba um número de 1 a 12 Converta para mês (usando switch) Mostre a estação do ano (usando if/else) 5.3 Números únicos em um array# Encontre e exiba apenas números que não se repetem:\nlet numeros = [1, 2, 2, 3, 4, 4, 5, 1]; for (let i = 0; i \u0026lt; numeros.length; i++) { let unico = true; for (let j = 0; j \u0026lt; numeros.length; j++) { if (i !== j \u0026amp;\u0026amp; numeros[i] === numeros[j]) { unico = false; break; } } if (unico) { console.log(numeros[i]); } } 6. Reflexão e discussão# Quando usar if/else if vs switch? Dê 3 exemplos onde cada um é melhor.\nExplique o fluxo: O que acontece quando um laço for tem uma condição que nunca é atingida?\nDebugging: Se um laço fica infinito, por que isso acontece geralmente?\nOtimização: Por que usar break em um laço melhora a performance?\nPadrão: Como estruturaria um programa com múltiplas validações?\nlet valor = 2; switch (valor) { case 1: console.log(\u0026#34;A\u0026#34;); case 2: console.log(\u0026#34;B\u0026#34;); case 3: console.log(\u0026#34;C\u0026#34;); break; default: console.log(\u0026#34;D\u0026#34;); }"},{"id":3,"href":"/docs/disciplinas/poo-ads/avaliacoes/","title":"Avaliações","section":"POO (ADS)","content":"Avaliações# Informações# Disciplina: Programação Orientada a Objetos\nCurso: Análise e Desenvolvimento de Sistemas\nPeríodo: 2026.1\nResumo sobre avaliações# Avaliação 1 - \\( AV1 \\) (Peso 2) Avaliação 2 - \\( AV2 \\) (Peso 2) Exercícios de sala - \\( EX \\) (Média da nota de exercícios tem peso 2) Projeto - \\( PJ \\) (Peso 4) A nota final (\\( NF \\)) é calculada através da média ponderada:\n\\[ NF = \\frac{AV1 \\times 2 \u0026#43; AV2 \\times 2 \u0026#43; EX \\times 2 \u0026#43; PJ \\times 4}{10} \\] Sobre as avaliações# As notas de avaliações vêm de exercícios, provas e projeto. A 1ª e 2ª avaliações são provas escritas, com questões discursivas ou objetivas. A quantidade de exercícios por bimestre é váriável, mas sempre maior que 2.\nA definição do projeto pode ser encontrada em Projeto.\nOs exercícios são avaliados em sala, nos momentos finais da aula. Todos os exercícios são planejados para serem feitos no tempo de aula. Um exercício não apresentado tem nota zero; apresentado parcialmente tem nota 50 e apresentado por completo tem nota 100. Os exercícios devem ser apresentados ao professor individualmente, no prazo estipulado, que geralmente é até o fim da aula, a menos que o professor defina outro prazo.\nAs datas de realização dos exercícios e provas podem ser encontradas na página Calendário. As datas podem mudar em comum acordo entre professor e maioria da turma.\nDúvidas frequentes sobre avaliações# Exercícios e projeto# Posso usar LLMs (IA) na resolução dos exercícios e no desenvolvimento do projeto? O uso de ferramentas de IA é uma decisão individual do estudante e não pode ser monitorado diretamente pelo professor. No entanto, espera-se que esse uso seja responsável e não substitua o processo de aprendizagem.\nCaso seja identificado o uso de IA e o estudante não consiga explicar, justificar ou defender adequadamente as soluções apresentadas, o exercício ou projeto poderá ter a nota zerada.\nEm outras palavras, o estudante é sempre responsável pelo conteúdo entregue, independentemente das ferramentas utilizadas.\nPosso mostrar os exercícios na aula seguinte? Não. Os exercícios não serão apresentados individualmente na aula seguinte, exceto se for explicitamente definido que todos os estudantes deverão apresentá-los.\nAs avaliações, exercícios e projeto são individuais? Avaliações (provas) são individuais; Exercícios são individuais; Projetos podem ser desenvolvidos em equipes de até 3 pessoas. Por que exercícios são individuais? É comum que estudantes peçam ajuda a colegas para resolver exercícios. Embora pedir ou oferecer ajuda não seja, em si, algo negativo, essa prática pode comprometer o aprendizado quando a ajuda se transforma na entrega da solução pronta. Nesses casos, o estudante que enfrenta dificuldades deixa de refletir sobre o problema, não consolida os conceitos trabalhados na disciplina e passa a depender de terceiros para resolver exercícios semelhantes.\nAvaliações# Quando ocorrerão as avaliações? As datas das avaliações estão disponíveis na página de Calendário.\nRecomenda-se consultá-la regularmente, pois atualizações podem ocorrer ao longo do semestre.\nComo são as avaliações? As avaliações podem ter questões discursivas (escritas) e/ou objetivas (de múltipla escolha).\nAs questões podem avaliar uma ou mais das seguintes capacidades:\nconhecimento teórico sobre programação orientada a objetos; escrita da continuação de código previamente iniciado; análise de trechos de código, incluindo a identificação de sua saída; análise de situações-problema para a elaboração de soluções em código. Qual é a duração das avaliações? A duração das avaliações será informada no momento de sua aplicação. Mas, geralmente, 100 minutos (ou duas aulas).\nÉ permitido consultar material durante a avaliação? Não. As avaliações são realizadas sem consulta a materiais, salvo indicação explícita em contrário.\nPosso usar computador ou celular durante a avaliação? Não. O uso de dispositivos eletrônicos durante as avaliações não é permitido, salvo indicação explícita em contrário.\nHaverá resolução das avaliações? Sim. As avaliações corrigidas serão discutidas em sala ou disponibilizadas conforme orientação informada após a correção.\nPosso ficar com minha avaliação corrigida? A sua avaliação será entregue para que você possa revisá-la e ver a correção, mas ela precisa ser devolvida ao professor.\nPosso fazer a avaliação de lápis comum? Você pode desenvolver um rascunho da forma que quiser, mas as respostas devem ser entregues escritas de caneta preta ou azul.\nHaverá avaliação de reposição? Sim. É permitida a reposição de uma avaliação sem necessidade de justificativa.\nO estudante que perder mais de uma avaliação poderá optar por qual delas deseja repor.\nNão há reposição de exercícios, projeto ou menor nota.\nNotas# Fiquei próximo da média mínima para aprovação (70). Posso receber pontos para atingir essa média? Sim, excepcionalmente, a nota pode ser ajustada para permitir a aprovação somente se todas as condições abaixo forem atendidas:\nmédia final maior ou igual a 66 e menor que 70; frequência nas aulas superior a 90%; entrega de todos os exercícios de sala; realização das duas avaliações previstas; entrega do projeto. Caso qualquer uma dessas condições não seja atendida, o ajuste não será concedido.\nFiquei próximo da média mínima para fazer a avaliação final (abaixo de 40). Posso receber pontos para atingir essa média? Sim, excepcionalmente, a nota pode ser ajustada para permitir a realização da avaliação final somente se todas as condições abaixo forem atendidas:\nmédia final maior ou igual a 36 e menor que 40; frequência nas aulas superior a 85%; entrega de todos os exercícios de sala; entrega do projeto. Caso qualquer uma dessas condições não seja atendida, o ajuste não será realizado.\nAvaliação final# Quanto preciso tirar na avaliação final? A tabela abaixo apresenta a nota mínima exigida na Avaliação Final (AF) de acordo com a Média Anual (MA) do estudante.\nMédia final do aluno (MA) Nota mínima na Avaliação Final (AF) 40 65 41 64 42 62 43 61 44 59 45 58 46 56 47 55 48 53 49 52 50 50 51 49 52 47 53 46 54 44 55 43 56 41 57 40 58 38 59 37 60 35 61 34 62 32 63 31 64 29 65 28 66 26 67 25 68 23 69 22 Qual o conteúdo da avaliação final? A avaliação final abrange todo o conteúdo programático da disciplina.\n"},{"id":4,"href":"/docs/disciplinas/poo-info/avaliacoes/","title":"Avaliações","section":"POO (Integrado)","content":"Avaliações# As notas de avaliações vêm de exercícios ou provas. A nota da 1ª avaliação de cada bimestre será a média dos exercícios realizados em sala e a 2ª avaliação será uma prova escrita. A quantidade de exercícios por bimestre é váriável, mas sempre maior que 2.\nAs datas de realização dos exercícios e provas podem ser encontradas na página Calendário.\n"},{"id":5,"href":"/docs/disciplinas/seginfo-ads/avaliacoes/","title":"Avaliações","section":"Seg. da Informação (ADS)","content":"Avaliações# Informações# Disciplina: Segurança da Informação\nCurso: Análise e Desenvolvimento de Sistemas\nAno: 2026.1\nResumo sobre avaliações# Exercícios de casa - \\( EX \\) - (média de exercícios) Avaliação - \\( AV \\) A nota final (\\( NF \\)) é calculada através da média ponderada:\n\\[ NF = \\frac{EX \u0026#43; AV}{2} \\] Os exercícios de sala serão contabilizados para contar como participação.\nSobre as avaliações# As notas das avaliações são obtidas por meio de exercícios e uma prova.\nA nota de exercícios do semestre corresponde à média dos exercícios de casa. Existem 4 exercícios de casa previstos no calendário. A nota de avaliação consiste em uma prova escrita, com questões discursivas e/ou objetivas.\nOs exercícios são disponibilizados por meio do Google Sala de Aula e consistem de formulários com questões objetivas. Exercícios entregues após o prazo sofrem uma penalidade de 30% na nota. Por exemplo, uma nota 90 em um exercício entregue no prazo passa a ser 63 quando a entrega ocorre fora do prazo.\nSerão realizadas práticas em sala de aula com o objetivo de exercitar os conteúdos trabalhados.\nEssas práticas não possuem valor numérico e não serão corrigidas individualmente. No entanto, a participação nas atividades será observada como indicativo de engajamento e acompanhamento da disciplina.\nAs datas de realização dos exercícios, práticas e provas estão disponíveis na página de Calendário. Essas datas podem ser alteradas mediante acordo entre o professor e a maioria da turma.\nDúvidas frequentes sobre avaliações# Exercícios e projeto# Posso usar LLMs (IA) na resolução dos exercícios? O uso de ferramentas de IA é uma decisão individual do estudante e não pode ser monitorado diretamente pelo professor. No entanto, espera-se que esse uso seja responsável e não substitua o processo de aprendizagem.\nCaso seja identificado o uso de IA e o estudante não consiga explicar, justificar ou defender adequadamente as soluções apresentadas, o exercício poderá ter a nota zerada.\nEm outras palavras, o estudante é sempre responsável pelo conteúdo entregue, independentemente das ferramentas utilizadas.\nPosso entregar exercícios fora do prazo? Sim. Mas exercícios entregues fora do prazo sofrerão uma penalidade de 30% na nota. Por exemplo, uma nota 90 em um exercício entregue no prazo passa a ser 63 quando a entrega ocorre fora do prazo.\nAs avaliações e exercícios são individuais? Sim.\nPor que exercícios são individuais? É comum que estudantes peçam ajuda a colegas para resolver exercícios. Embora pedir ou oferecer ajuda não seja, em si, algo negativo, essa prática pode comprometer o aprendizado quando a ajuda se transforma na entrega da solução pronta. Nesses casos, o estudante que enfrenta dificuldades deixa de refletir sobre o problema, não consolida os conceitos trabalhados na disciplina e passa a depender de terceiros para resolver exercícios semelhantes.\nAvaliações# Quando ocorrerão as avaliações? As datas das avaliações estão disponíveis na página de Calendário.\nRecomenda-se consultá-la regularmente, pois atualizações podem ocorrer ao longo do semestre.\nComo são as avaliações? As avaliações podem ter questões discursivas (escritas) e/ou objetivas (de múltipla escolha).\nAs questões podem avaliar uma ou mais das seguintes capacidades:\nconhecimento teórico sobre segurança da informação; análise de situações-problema para a elaboração de soluções. Qual é a duração das avaliações? A duração das avaliações será informada no momento de sua aplicação. Mas, geralmente, 100 minutos (ou duas aulas).\nÉ permitido consultar material durante a avaliação? Não. As avaliações são realizadas sem consulta a materiais, salvo indicação explícita em contrário.\nPosso usar computador ou celular durante a avaliação? Não. O uso de dispositivos eletrônicos durante as avaliações não é permitido, salvo indicação explícita em contrário.\nHaverá resolução das avaliações? Sim. As avaliações corrigidas serão discutidas em sala ou disponibilizadas conforme orientação informada após a correção.\nPosso ficar com minha avaliação corrigida? A sua avaliação será entregue para que você possa revisá-la e ver a correção, mas ela precisa ser devolvida ao professor.\nPosso fazer a avaliação de lápis comum? Você pode desenvolver um rascunho da forma que quiser, mas as respostas devem ser entregues escritas de caneta preta ou azul.\nHaverá avaliação de reposição? Sim. É permitida a reposição da avaliação sem necessidade de justificativa.\nNão há reposição de exercícios ou menor nota, nem reposição da reposição.\nNotas# Fiquei próximo da média mínima para aprovação (70). Posso receber pontos para atingir essa média? Sim, excepcionalmente, a nota pode ser ajustada para permitir a aprovação somente se todas as condições abaixo forem atendidas:\nmédia final maior ou igual a 66 e menor que 70; frequência nas aulas superior a 90%; participação em todas as práticas realizadas em sala; entrega no prazo de todos os exercícios. realização da avaliação; Caso qualquer uma dessas condições não seja atendida, o ajuste não será concedido.\nFiquei próximo da média mínima para fazer a avaliação final (abaixo de 40). Posso receber pontos para atingir essa média? Sim, excepcionalmente, a nota pode ser ajustada para permitir a realização da avaliação final somente se todas as condições abaixo forem atendidas:\nmédia final maior ou igual a 36 e menor que 40; frequência nas aulas superior a 85%; participação em todas as práticas realizadas em sala; entrega no prazo de todos os exercícios. realização da avaliação; Caso qualquer uma dessas condições não seja atendida, o ajuste não será realizado.\nAvaliação final# Quanto preciso tirar na avaliação final? A tabela abaixo apresenta a nota mínima exigida na Avaliação Final (AF) de acordo com a Média Anual (MA) do estudante.\nMédia final do aluno (MA) Nota mínima na Avaliação Final (AF) 40 65 41 64 42 62 43 61 44 59 45 58 46 56 47 55 48 53 49 52 50 50 51 49 52 47 53 46 54 44 55 43 56 41 57 40 58 38 59 37 60 35 61 34 62 32 63 31 64 29 65 28 66 26 67 25 68 23 69 22 Qual o conteúdo da avaliação final? A avaliação final abrange todo o conteúdo programático da disciplina.\n"},{"id":6,"href":"/docs/disciplinas/poo-ads/calendario/","title":"Calendário","section":"POO (ADS)","content":"Calendário# Informações# Disciplina: Programação Orientada a Objetos\nCurso: Análise e Desenvolvimento de Sistemas\nPeríodo: 2026.1\nFrequência\nPara ser aprovado na disciplina, o estudante deve ter frequência mínima de 75% da carga horária total.\nA disciplina de Programação Orientada a Objetos possui 160 horas-aula. Isso significa que o estudante pode ter no máximo 39 faltas (ou 10 dias de aula).\nCaso o número de faltas seja 40 ou mais, o estudante estará reprovado por falta, independentemente das notas obtidas.\nCronograma# Fevereiro 09 (seg) Apresentação da disciplina Introdução à linguagem Java 5/160 aulas 10 (ter) Exercício: Introdução à linguagem Java 9/160 aulas 16 (seg) Feriado: Carnaval --- 17 (ter) Feriado: Carnaval --- 23 (seg) Introdução ao Git 14/160 aulas 24 (ter) Exercício: Introdução ao Git 18/160 aulas Março 02 (seg) Tipos primitivos Classes e objetos 23/160 aulas 03 (ter) Exercício: Tipos, classes e objetos 27/160 aulas 09 (seg) Entrada e saída Encapsulamento Sobreposição e sobrecarga 32/160 aulas 10 (ter) Exercício: Entrada e saída Exercício: Encapsulamento, Sobreposição e sobrecarga 36/160 aulas 16 (seg) Composição de objetos Troca de mensagens entre objetos 41/160 aulas 17 (ter) Exercício: Composição de objetos e troca de mensagens entre objetos 45/160 aulas 23 (seg) Herança Interfaces Classes abstratas 50/160 aulas 24 (ter) Exercício: Herança, interfaces e classes abstratas 54/160 aulas 25 (qua) Aula extra - 4 aulas 58/160 aulas 30 (seg) Polimorfismo 63/160 aulas 31 (ter) Avaliação 1 A prova abrange todos os tópicos já ministrados até essa data. 67/160 aulas Abril 06 (seg) Criação e tratamento de exceções 72/160 aulas 07 (ter) Exercício: Criação e tratamento de exceções 76/160 aulas 13 (seg) Java Collections API Java Streams API 81/160 aulas 14 (ter) Exercício: Java Collections API e Java Streams API 85/160 aulas 21 (ter) Feriado: Dia de Tiradentes --- 27 (seg) Interfaces Gráficas (Java Swing) 90/160 aulas 28 (ter) Exercício: Interfaces Gráficas (Java Swing) 94/160 aulas Maio 04 (seg) Interfaces Gráficas (Java Swing) 99/160 aulas 05 (ter) Exercício: Interfaces Gráficas (Java Swing) 103/160 aulas 11 (seg) Interfaces Gráficas (JavaFX) 108/160 aulas 12 (ter) Exercício: Interfaces Gráficas (JavaFX) 112/160 aulas 18 (seg) Threads e programação assíncrona 117/160 aulas 19 (ter) Exercício: Threads e programação assíncrona 121/160 aulas 20 (qua) Aula extra - 3 aulas 124/160 aulas 25 (seg) Java 2D 129/160 aulas 26 (ter) Exercício: Java 2D 133/160 aulas Junho 01 (seg) Empacotamento Bibliotecas externas 138/160 aulas 02 (ter) Avaliação 2 A prova abrange todos os tópicos já ministrados até essa data. 142/160 aulas 08 (seg) Reposição de avaliações É permitido repor uma avaliação sem justificativa. Para repor duas avaliações, é necessário apresentar justificativa. Não há reposição de menor nota. 147/160 aulas 09 (ter) Acompanhamento de projetos 151/160 aulas 15 (seg) Apresentação de projetos 156/160 aulas 16 (ter) Apresentação de projetos 160/160 aulas 18 Término do semestre --- 23 Data provável da avaliação final --- "},{"id":7,"href":"/docs/disciplinas/poo-info/calendario/","title":"Calendário","section":"POO (Integrado)","content":"Calendário# Programação Orientada a Objetos# Curso: Técnico Integrado em Informática\nAno: 2026\nCalendário resumido# Avaliações\nAcesse Avaliações para informações sobre como as avaliações bimestrais serão conduzidas.\nInício das aulas: 09/02 1º bimestre 1ª avaliação: 16/03 2ª avaliação: 06/04 Recuperação: 13/04 2º bimestre 1ª avaliação: 2ª avaliação: Recuperação: 3º bimestre 1ª avaliação: 2ª avaliação: Recuperação: 4º bimestre 1ª avaliação: 2ª avaliação: Recuperação: Prova final (data provável): 21/12 Calendário detalhado# Fevereiro 09 Início do 1º Bimestre Conteúdo Apresentação da disciplina Revisão de JavaScript 3/120 aulas 16 Feriado: Carnaval --- 23 Revisão de JavaScript */120 aulas Março 02 Revisão de JavaScript Classes e Objetos */120 aulas 09 Classes e Objetos */120 aulas 16 Avaliação 1 A avaliação abrange todos os tópicos já ministrados até essa data. */120 aulas 23 Encapsulamento */120 aulas 30 Encapsulamento */120 aulas Abril 06 Avaliação 2 A avaliação abrange todos os tópicos já ministrados até essa data. */120 aulas 13 Recuperação? */120 aulas 17 Término do 1º Bimestre */120 aulas 20 Início do 2º Bimestre A definir */120 aulas 27 A definir */120 aulas Maio 04 A definir */120 aulas 11 A definir */120 aulas 18 A definir */120 aulas 25 A definir */120 aulas Junho 01 A definir */120 aulas 08 A definir */120 aulas 15 A definir */120 aulas 22 A definir */120 aulas 23 Término do 2º Bimestre */120 aulas 25 Início das férias docentes */120 aulas 2025 Julho 24 Término das férias docentes */120 aulas 27 Início do 3º Bimestre A definir ---/160 aulas Agosto 03 A definir */120 aulas 10 A definir */120 aulas 17 A definir */120 aulas 24 A definir */120 aulas 31 A definir */120 aulas Setembro 07 Feriado: Independência do Brasil A definir */120 aulas 14 A definir */120 aulas 21 A definir */120 aulas 28 A definir */120 aulas Outubro 05 A definir */120 aulas 06 Término do 3º Bimestre A definir */120 aulas 07 Início do 4º Bimestre A definir */120 aulas 12 Feriado: Dia de Nossa Senhora Aparecida */120 aulas 19 A definir */120 aulas 26 A definir */120 aulas Novembro 02 Feriado: Dia de Finados */120 aulas 09 A definir */120 aulas 16 A definir */120 aulas 23 A definir */120 aulas 30 A definir */120 aulas Dezembro 07 A definir */120 aulas 14 A definir */120 aulas 17 Término do 4º Bimestre */120 aulas 21 Data provável da avaliação final */120 aulas "},{"id":8,"href":"/docs/disciplinas/seginfo-ads/calendario/","title":"Calendário","section":"Seg. da Informação (ADS)","content":"Calendário# Informações# Disciplina: Segurança da Informação\nCurso: Análise e Desenvolvimento de Sistemas\nPeríodo: 2026.1\nFrequência\nPara ser aprovado na disciplina, o estudante deve ter frequência mínima de 75% da carga horária total.\nA disciplina de Segurança da Informação possui 40 horas-aula. Isso significa que o estudante pode ter no máximo 9 faltas (ou 5 dias de aula).\nCaso o número de faltas seja 10 ou mais, o estudante estará reprovado por falta, independentemente das notas obtidas.\nCronograma# Fevereiro 10 Apresentação da disciplina Introdução e conceitos básicos sobre segurança da informação 2/40 aulas 17 Feriado: Carnaval --- 24 Introdução e conceitos básicos sobre segurança da informação (continuação) 4/40 aulas Março 03 Criptografia simétrica 6/40 aulas 10 Criptografia assimétrica Gerência de chaves 8/40 aulas 17 Funções hash criptográficas 11/40 aulas Aula extra: 1 24 Prática em sala: Criptografia e funções Hash Criptográficas Exercício de casa 1: Conceitos básicos, criptografia e funções hash criptográficas 14/40 aulas Aula extra: 1 31 Segurança de dispositivos Segurança de dispositivos de rede Segurança de rede local Conceitos e configuração de firewalls 16/40 aulas Abril 07 Soluções de segurança e tecnologias Sistemas de Prevenção de Intrusão: IPS Acesso remoto seguro: SSH Segurança em correio eletrônico: PGP e S/MIME Segurança em camada de transporte: SSL/TLS Segurança em camada de rede: VPN e IPSe 18/40 aulas 14 Soluções de segurança e tecnologias (continuação) Exercício de casa 2: Segurança de dispositivos; soluções de segurança e tecnologias 20/40 aulas 21 Feriado: Dia de Tiradentes --- 28 Avaliação 1 A prova abrange todos os tópicos já ministrados até essa data. Segurança em redes sem fio 22/40 aulas Maio 05 Prática em sala: Segurança em redes sem fio Exercício de casa 3: Segurança em redes sem fio 25/40 aulas Aula extra: 1 12 Vulnerabilidades em aplicações CSRF - Cross-Site Request Forgery SQL Injection XSS - Cross-Site Scripting 27/40 aulas 19 Prática em sala: Vulnerabilidades em aplicações 30/40 aulas Aula extra: 1 26 Vulnerabilidades em aplicações Vulnerabilidades em autenticação 32/40 aulas Junho 02 Vulnerabilidades em aplicações Vulnerabilidades em autenticação (continuação) 35/40 aulas Aula extra: 1 09 Prática em sala: Vulnerabilidades em autenticação Exercício de casa 4: Vulnerabilidades em aplicações 38/40 aulas Aula extra: 1 16 Reposição de avaliações É permitido repor uma avaliação sem justificativa. Para repor duas avaliações, é necessário apresentar justificativa. Não há reposição de menor nota. 40/40 aulas 18 Término do semestre --- 23 Data provável da avaliação final --- "},{"id":9,"href":"/docs/disciplinas/","title":"Disciplinas","section":"Docs","content":"Informações gerais da disciplina.\n"},{"id":10,"href":"/docs/disciplinas/poo-ads/exercicios/","title":"Exercícios","section":"POO (ADS)","content":"Exercícios# Lista 01 - Introdução à linguagem Java\n"},{"id":11,"href":"/docs/disciplinas/poo-info/revisao-javascript/","title":"JavaScript - uma breve introdução à linguagem","section":"POO (Integrado)","content":"JavaScript - uma breve introdução à linguagem# Antes de entrarmos propriamente em programação orientada a objetos, é fundamental garantir que todos tenham uma base sólida dos fundamentos da linguagem JavaScript.\nEsta revisão tem como objetivo nivelar conceitos, corrigir vícios comuns e preparar o terreno para o uso consciente de classes, objetos e métodos.\nDominar esses fundamentos é essencial para compreender como objetos armazenam estado, como métodos operam sobre dados e como erros sutis surgem em sistemas maiores. A partir daqui, passamos a organizar esse conhecimento usando os princípios da programação orientada a objetos.\nÍndice# 1. Fundamentos essenciais da linguagem\n2. Estruturas de controle\n3. Funções\n"},{"id":12,"href":"/docs/disciplinas/poo-ads/exercicios/lista01/","title":"Lista 01","section":"Exercícios","content":"Lista 01# Instruções# Neste ponto da disciplina, ainda não vimos operações de entrada e saída. Por isso, para simular a entrada dos programas, você deverá, simplesmente, declarar variáveis e inicializá-las com os valores que seriam lidos na entrada.\nTodos os exercícios devem ser feitos em um único programa Java, seguindo a estrutura fornecida no link a seguir. Essa estrutura consiste de um programa com um menu inicial para escolha do exercício que será executada e um método separado para cada exercício. Você preencherá apenas o corpo desses métodos, implementando a lógica pedida em cada questão. Não crie arquivos separados nem coloque toda a lógica dentro do main.\nA correção será feita presencialmente, com o professor executando o programa na sua máquina. Algumas questões serão escolhidas na hora e testadas com valores também escolhidos na hora. A avaliação levará em conta se o programa compila e se a lógica das questões está correta. Detalhes de formatação não serão avaliados, mas respostas fixas, ausência das estruturas pedidas ou desrespeito à estrutura combinada implicam perda de pontuação.\nBaixe a estrutura para preenchimento do código das questões aqui\nExercícios# Declare uma variável idade, representando a idade de uma pessoa e use uma estrutura if/else para determinar se ela é maior de idade (18 anos ou mais) ou não, e imprima a mensagem correspondente. \u0026ldquo;Maior\u0026rdquo;, quando o usuário for maior de idade ou \u0026ldquo;Menor\u0026rdquo;, caso contrário. Declare uma variável contendo um número e informe se ele é par ou ímpar. \u0026ldquo;É par\u0026rdquo;, quando o número for par ou \u0026ldquo;É ímpar\u0026rdquo;, caso contrário. Declare duas variáveis contendo dois números e mostre qual deles é maior. Imprima a mensagem \u0026ldquo;x é o maior\u0026rdquo;, onde x é o maior número entre o dois, ou \u0026ldquo;os números são iguais\u0026rdquo;, caso sejam iguais. Declare uma variável contendo um valor de temperatura em graus Celsius e informe se está frio (menor que 20) ou quente (20 ou mais). Declare uma variável contendo a nota de um aluno (de 0 a 10). Se a nota for 6.8 ou mais, mostre \u0026ldquo;Aprovado\u0026rdquo;. Senão, mostre \u0026ldquo;Reprovado\u0026rdquo;. Declare uma variável contendo o valor do consumo de energia (em kWh). Se for até 100, o preço é 0,50 por kWh. Se for maior que 100, o preço é 0,70 por kWh. Calcule e mostre o valor total. Escreva um programa que faça uma contagem regressiva de 10 a 0. Use um laço for para a contagem. Crie um programa que use um laço while para somar todos os números pares de 1 a 100. Declare uma variável contendo um número e imprima a tabuada desse número, de 1 a 10. Use um laço for. Declare uma variável contendo um número inteiro e escreva um programa para verificar se ele é primo. Declare uma variável contendo uma única letra. Use uma estrutura switch para verificar se a letra é uma vogal ou uma consoante. Declare uma variável contendo uma frase e conte quantas vezes a letra \u0026lsquo;a\u0026rsquo; (minúscula ou maiúscula) aparece na frase. Crie um array de inteiros pré-definido. Declare uma variável contendo um número e verifique se esse número está presente no array. Crie um array de double para armazenar 5 notas. Busque como preencher o array na inicialização e, em seguida, calcule e imprima a média das notas. Crie um array de String com os nomes de 5 frutas. Percorra o array e imprima cada nome. Considere o código desenvolvido na questão 15. Imprima apenas as frutas que começam com a letra \u0026lsquo;M\u0026rsquo;. "},{"id":13,"href":"/docs/disciplinas/poo-ads/","title":"POO (ADS)","section":"Disciplinas","content":"Programação Orientada a Objetos# Curso: Análise e Desenvolvimento de Sistemas\nPeríodo: 2026.1\nInformações gerais# Verifique as páginas específicas para informações sobre Avaliações e Calendário\nFerramentas e ambiente# Linguagem: Java\nIDE recomendada: IntelliJ IDEA\nÉ possível obter uma licença educacional para o IntelliJ IDEA usando seu e-mail acadêmico.\nClique e siga as instruçõesMetodologia# A disciplina será desenvolvida por meio de aulas expositivas dialogadas, intercaladas com atividades práticas em laboratório, nas quais os conceitos de programação orientada a objetos serão aplicados de forma progressiva. Durante as aulas, serão apresentados exemplos práticos, análise de código e demonstrações de implementação, seguidas da resolução de exercícios orientados pelo professor.\nOs estudantes realizarão exercícios semanais, geralmente a cada unidade, envolvendo a criação, modificação e refatoração de programas, com ênfase na utilização de classes, objetos, encapsulamento, herança e polimorfismo. Parte dos exercícios poderá ser proposta com código parcialmente implementado e/ou propositalmente incorreto, incentivando a análise, compreensão e extensão de soluções existentes, além de possibilitar o diagnóstico de problemas no aprendizado dos estudantes.\nAs atividades práticas serão desenvolvidas em ambiente de laboratório, utilizando as ferramentas listadas nos recursos didáticos, envolvendo situações próximas às encontradas no contexto profissional. O acompanhamento do aprendizado será contínuo, com feedback frequente sobre os exercícios realizados, discussões em sala e orientações para melhoria das soluções apresentadas.\nNo decorrer da disciplina, são propostas atividades individuais e em grupo, estimulando a autonomia e a troca de experiências entre os estudantes.\nMateriais úteis# 1. Introdução à Programação Orientada a Objetos usando Java - Rafael Santos 1.1. Informações e material adicional para o livro 2. Java e Orientação a Objetos - Alura 3. Introdução à Programação Orientada a Objetos (POO) - Fundação Bradesco 4. Java, Java, Java - Object-Oriented Problem Solving - Third Edition - R. Morelli and R. Walde\n"},{"id":14,"href":"/docs/disciplinas/poo-ads/projeto/","title":"Projeto","section":"POO (ADS)","content":"Projeto# TODO\n"},{"id":15,"href":"/docs/disciplinas/poo-info/","title":"POO (Integrado)","section":"Disciplinas","content":"Programação Orientada a Objetos# Curso: Técnico Integrado em Informática\nAno: 2026\nInformações gerais# Verifique as páginas específicas para informações sobre Avaliações e Calendário\nFerramentas e ambiente# Linguagem: JavaScript\nIDE recomendada: Visual Studio Code\nInstalação do Visual Studio Code (VSCode)\nEm algumas situações, o VSCode pode estar indisponível na máquina do laboratório ou você pode ter problemas para instalar ou executar o VSCode no seu computador. Siga o guia de instalação do VSCode para tentar solucionar esses problemas.\nGuia de instalação do VSCodeFrequência# A presença mínima exigida é de 75%. A ausência em avaliações não garante reposição. Para ter direito à reposição, é necessário que o aluno justifique sua ausência através do SUAP. A entrega da justificativa de falta não é feita para o professor. "},{"id":16,"href":"/docs/disciplinas/poo-info/revisao-javascript/3-funcoes/","title":"3. Funções","section":"JavaScript - uma breve introdução à linguagem","content":"3. Funções# Em JavaScript, funções não servem apenas para organizar código.\nElas são valores, podem ser armazenadas em variáveis, passadas como argumento e retornadas por outras funções. São consideradas \u0026ldquo;cidadãs de primeira classe\u0026rdquo; porque são tratadas como valores comuns da linguagem.\nO objetivo desta seção é preparar o estudante para:\nentender métodos em classes; compreender callbacks; perceber como o encapsulamento começa antes mesmo da orientação a objetos. Encapsulamento é a ideia de esconder detalhes internos de um código e expor apenas o que é necessário para usá-lo. No contexto de funções: quem usa uma função não precisa saber como ela funciona por dentro, precisa saber apenas o que ela faz e como chamá-la.\nO que é uma função?# Uma função é um bloco de código reutilizável que pode receber dados (parâmetros), executa uma sequência de instruções e pode ou não retornar um valor.\nfunction saudacao() { console.log(\u0026#34;Olá!\u0026#34;); }Para executar a função, usamos parênteses:\nsaudacao();Declaração de funções# A forma mais tradicional de definir uma função é a declaração de função:\nfunction soma(a, b) { return a + b; } let resultado = soma(2, 3); console.log(resultado); // 5 As características importantes a serem mencionadas são: funções geralmente têm um nome (às vezes podem não ter) e pode ser chamada antes ou depois da sua definição no código. É adequado usá-la, quando a função representa uma ação ou regra clara do sistema.\nParâmetros e retorno# Parâmetros são variáveis locais que recebem valores no momento da chamada da função.\nfunction dobro(numero) { return numero \\* 2; } dobro(4); // 8 Se nenhum valor for passado, o parâmetro recebe undefined.\ndobro(); // NaN O return (retorno) encerra a execução da função e define o valor retornado.\nfunction verificaIdade(idade) { if (idade \u0026gt;= 18) { return \u0026#34;Maior de idade\u0026#34;; } return \u0026#34;Menor de idade\u0026#34;; } Uma função pode ter vários return, mas apenas um será executado por chamada.\nEscopo de função# Variáveis declaradas dentro de uma função só existem dentro dela.\nfunction exemplo() { let x = 10; console.log(x); } exemplo(); // console.log(x); // Erro Isso é um primeiro contato com encapsulamento: dados internos não vazam para fora.\nFunções anônimas# Uma função não precisa ter nome. Funções sem nome são chamadas de funções anônimas.\nlet saudacao = function () { console.log(\u0026#34;Olá!\u0026#34;); }; saudacao();Nesse caso, a função é armazenada em uma variável. Quem nomeia a função é a variável.\nFunções seta (Arrow functions)# Funções seta são uma forma mais concisa de escrever funções.\nlet soma = (a, b) =\u0026gt; { return a + b; };Quando o corpo tem apenas uma expressão, o return é implícito:\nlet soma = (a, b) =\u0026gt; a + b;Outro exemplo:\nlet dobro = x =\u0026gt; x \\* 2;Funções seta tornam o código mais enxuto e são muito usadas como callbacks, mas não substituem completamente funções tradicionais (isso ficará claro quando avançarmos na disciplina de POO).\nFunções como valores# Em JavaScript, funções são valores como qualquer outro. Isso significa que uma função pode ser atribuída a uma variável, passada como argumento ou até retornada por outra função.\nFunção como argumento (callback)\nfunction executar(funcao) { funcao(); } function mensagem() { console.log(\u0026#34;Executando função\u0026#34;); } executar(mensagem);Nesse trecho de código, mensagem não é executada imediatamente. Ela é passada como valor e executar decide quando chamá-la.\nExemplo prático com lógica:\nfunction processar(valor, operacao) { return operacao(valor); } let dobro = (x) =\u0026gt; x * 2; let triplo = (x) =\u0026gt; x * 3; processar(5, dobro); // 10 processar(5, triplo); // 15 Esse padrão é a base de eventos e callbacks.\nFunções retornando funções# Uma função também pode retornar outra função:\nfunction criarMultiplicador(fator) { return function (numero) { return numero * fator; }; } let duplicar = criarMultiplicador(2); duplicar(5); // 10 Esse tipo de construção será importante para compreender encapsulamento funcional e interpretar código mais avançado em JavaScript.\nAtividades sugeridas# 1. Rastreamento de execução# function teste(x) { return x \\* 2; } let y = teste(3); console.log(y);Qual é o valor final de y?\n2. Função sem retorno# function imprime(valor) { console.log(valor); } let resultado = imprime(10); console.log(resultado); O que será impresso? Qual é o valor de resultado? 3. Função como argumento# function executar(a, b, operacao) { return operacao(a, b); } let soma = (x, y) =\u0026gt; x + y; let sub = (x, y) =\u0026gt; x - y; executar(10, 5, soma); executar(10, 5, sub);Por que operacao precisa ser uma função?\n4. Conversão de função# Reescreva a função abaixo como função seta (arrow function):\nfunction quadrado(x) { return x * x; }5. Exercício conceitual# Explique, com suas palavras:\na. Q que significa dizer que funções são “cidadãos de primeira classe”? b. Por que isso é importante para a programação orientada a objetos em JavaScript?\n"},{"id":17,"href":"/docs/disciplinas/poo-info/revisao-javascript/anotacoes/","title":"Anotações","section":"JavaScript - uma breve introdução à linguagem","content":" Herança não é o centro da POO em JavaScript Em JavaScript, herança existe, mas não é o principal mecanismo de reutilização.\nA reutilização ocorre via composição de objetos, delegação de comportamento e passagem de funções.\nTudo isso depende de funções serem cidadãos de primeira classe.\n"},{"id":18,"href":"/docs/disciplinas/seginfo-ads/","title":"Seg. da Informação (ADS)","section":"Disciplinas","content":"Metodologia# A disciplina será desenvolvida por meio de aulas expositivas dialogadas, nas quais serão apresentados e discutidos os principais conceitos de segurança da informação, contextualizados em cenários reais e atuais. As aulas priorizarão a compreensão dos conceitos, estimulando a participação ativa dos estudantes por meio de questionamentos e discussões orientadas.\nComo estratégia de consolidação do aprendizado, será proposto um exercício de fixação em todas as aulas ou, quando pertinente, em aulas alternadas, com o objetivo de reforçar os conceitos abordados, desenvolver o raciocínio crítico e promover a aplicação prática do conteúdo teórico. Os exercícios poderão envolver análise de situações-problema, interpretação de cenários de risco, identificação de vulnerabilidades e proposição de medidas de segurança.\nPara os temas em que a abordagem prática se mostrar adequada, serão realizadas atividades práticas orientadas, permitindo aos estudantes vivenciar, de forma controlada, situações relacionadas à segurança da informação.\nO acompanhamento do aprendizado será contínuo, por meio da análise dos exercícios realizados, discussões em sala e feedback fornecido pelo professor, visando ao desenvolvimento progressivo da compreensão técnica e crítica dos estudantes sobre os temas da disciplina.\n"},{"id":19,"href":"/docs/posts/primeiro-post/","title":"Primeiro Post","section":"Atualizações","content":"Introduction# This is bold text, and this is emphasized text.\nVisit the Hugo website!\n"}]